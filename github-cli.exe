#!/usr/bin/env python3.3
import json, os, requests, sys, subprocess

# Dear user: this is the name we call your bot
CMD_NAME = "github-cli"
# Dear user: change this path to whatever/wherever you want your .ini
INI_FILE = "./myrepo.ini"

class Log:
    """
        Colored printouts
    """
    def error(self, msg): print("\033[31mError: %s\033[0m" % msg); exit(1)
    def note(self, msg): print("\033[34m%s\033[0m" % msg)
    def success(self, msg): print("\033[32m%s\033[0m" % msg)
    def warn(self, msg): print("\033[35mWarning: %s\033[0m" % msg)

class ConfigParser:
    """
        Very simple parser for the .ini file.
    """
    def __init__(self, filename):
        self.config_filename = filename

    def to_dict(self):
        config_dict = {}
        with open(self.config_filename, 'r') as config_file:
            for line in config_file:
                stripped = line.strip()
                if " = " in stripped:
                    # Add data to config dictionary. Everything is strings
                    key, val = stripped.split(" = ", 1)
                    config_dict[key] = val
        return config_dict

class Git:
    """
        Wrapper for executing git commands. 
        Could benefit from more fancy stuff with the git-dir.
    """

    def __init__(self, config):
        self.currentBranch = None
        self.git_dir = config['github.home']
        self.log = Log()

    def command(self, cmd, attemptRecovery=True):
        fullCommand = "git --git-dir=%s/.git %s" % (self.git_dir, cmd)
        print("> %s" % fullCommand)
        try: 
            output = str(subprocess.check_output(fullCommand, shell=True),encoding="utf-8")
            return "\n".join(line for line in output.split("\n") if line)
        except subprocess.CalledProcessError as cpe: 
            if attemptRecovery:
                # If not trying to recover, do nothing, let the caller finish its routine.
                self.log.warn("Encountered error, checking out current branch")
                self.command("checkout %s" % self.currentBranch, attemptRecovery=False)
                self.handleError(cmd)

    def handleError(self, cmd):
        """
            Attempt to give descriptive error message based on the result of 'git status'
        """
        status_str = self.command("status")
        if "You have unmerged paths" in status_str:
            self.log.error("Merge conflict detected. Mark resolution and try again.")
        elif False:
            pass
        else:
            # Generic error
            self.log.error("Failed to execute 'git %s'\nMake sure 'github.home' is properly set in the .ini" % cmd)

class GithubApi:
    """
        Interfacing with github
    """

    def __init__(self, config):
        """
            2013-09-02:
                Read in the config file. This is a very simple parser.
        """
        self.api_url = "https://api.github.com/repos/%s/%s" % \
            (config['github.owner'], config['github.repo'])
        self.github_token = config['github.token']
        self.log = Log()
    
    def eraseLabel(self, issue_number, label):
        url = "%s/issues/%s/labels/%s" % (self.api_url, issue_number, label)
        return self.getResponse(url, data="DELETE")
    
    def getIssueData(self, issue_number):
        url = "%s/issues/%s" % (self.api_url, issue_number)
        return self.getResponse(url)

    def getPullRequests(self):
        url = "%s/pulls" % self.api_url
        return self.getResponse(url)

    def getResponse(self, url, data=None):
        # Add access token to url
        url = "%s?access_token=%s" % (url, self.github_token)
        if data is None:
            response = requests.get(url)
        elif data=="DELETE":
            # 2013-08-12: This is a bit of a hack
            response = requests.delete(url)
        else: 
            # 2013-08-12: Post request. This is a more acceptable hack.
            response = requests.post(url, data=json.dumps(data))
        if 200 <= response.status_code <= 299:
            return response.json()
        else:
            self.log.error("Failed to get response from github api for url %s.\nMake sure 'github.owner', 'github.repo', and 'github.token' are properly set in the .ini" % url)

    def postLabel(self, issue_number, data):
        url = "%s/issues/%s/labels" % (self.api_url, issue_number)
        return self.getResponse(url, data)

    def postPullRequest(self, data):
        url = "%s/pulls" % self.api_url
        return self.getResponse(url, data)

class Work:
    """
        Dispatch for the actual commands. checkout, commit, review, close, etc
    """

    def __init__(self, config):
        # Configurations dictionary
        self.config = config
        # User-entered command
        self.command = None 
        # Used to execute git commands
        self.git = Git(self.config)
        # On error, return to this branch
        self.git.currentBranch = None
        # Pretty printer
        self.log = Log()

    def add(self, pattern, options=[]):
        """
            Search for files matching prefix `pattern` or, if `pattern` is a git catchall, everything.
        """
        added = False
        files_added = []
        if pattern in ["-A", "-u", "."]:
            # Revert to github's behavior
            status_str = self.git.command("status")
            changed = "Changes not staged for commit:" in status_str
            untracked = "Untracked files:" in status_str
            # Decide based on git's behavior, read from here: http://stackoverflow.com/questions/572549/difference-between-git-add-a-and-git-add?rq=1
            if ((pattern in [".", "-A"]) and (changed or untracked)) or ((pattern == "-u") and changed):
                added = True
                self.git.command("add %s" % pattern)
        else:
            # Use argument `pattern` to find files.
            found_str = str(subprocess.check_output("find . -name '%s*'" % pattern, shell=True),encoding="utf-8")
            files_added = []
            for fname in (x for x in found_str.split("\n") if x):
                try:
                    self.git.command("add %s %s" % (" ".join(options), fname))
                    files_added.append(fname)
                    added = True
                except:
                    # Do not fail on failed attempt to add a file. Just ignore it.
                    pass
        # Check if we added anything
        if not added:
            self.log.warn("Did not find any files to add")

    def commit(self, message, options=[]):
        """
            Automatically prepend issue number to commit message
        """
        commit_message = "\"[#%s] %s\"" % (self.issue, message)
        # Check if there's anything to commit
        status_str = self.git.command("status")
        if (not ("Changes to be committed:" in status_str)) or ("conclude merge" in status_str):
            # Nothing staged to commit, not in middle of a merge
            self.log.error("Nothing to commit (working directory clean)")
        # Otherwise, proceed with commit
        self.log.note("About to commit:") 
        print(commit_message)
        self.log.note("to %s. Is this correct? (y / n)" % (self.git.currentBranch))
        answer = input().lower()
        while answer not in ['y', 'n']:
            print("Please answer 'y' or 'n'")
            answer = input().lower()
        if answer == 'y':
            self.git.command("commit %s -m %s" % (" ".join(options), commit_message))
            self.log.success("Success!")
        else:
            self.log.note("Commit aborted")

    def close(self):
        """
            All done with the issue. Merge into the parent. 
        """
        # Merge
        self.git.command("checkout %s" % self.target)
        self.git.command("merge --no-ff -m \"MERGING #%s INTO %s MADE BY %s\" %s" % (self.issue, self.target, CMD_NAME, self.git.currentBranch))
        # Manage labels
        self.api.eraseLabel(self.issue, "pending-review")
        self.api.postLabel(self.issue, data=['resolved'])
        # Push to origin
        self.git.command("push origin")
        # Party!
        self.log.success("=== Issue Resolved ===")

    def checkout(self, issue_number, pull=False):
        """
            Find and check out the correct issue branch. 
        """
        issue_data = self.api.getIssueData(issue_number)
        if issue_data is None:
            self.log.error("Checkout failed. Could not retrieve issue data for issue number #%s" % issue_number)
        title = issue_data['title']
        target = self._getTarget(issue_data)
        branch = "-".join([target, issue_number])
        if branch == self.git.currentBranch:
            self.log.warn("Already on branch '%s'. Exiting..." % branch) 
        if branch in self.branches or "remotes/origin/%s" % branch in self.branches:
            if pull:
                self.pull(True, branch)
            else:
                self.git.command("checkout %s" % branch)
        else:
            # Check if the target branch exists locally. If not, create it.
            if target not in self.branches:
                self.log.note("Creating new branch origin/%s" % target)
                self.git.command("checkout -b %s" % target)
            # Sync target
            self.pull(True, target)
            # Create new issue branch
            self.git.command("checkout -b %s" % branch)
        self.log.success("Successfully checked out Issue #%s: %s" % (issue_number, title))
        self.log.note("Target: %s" % target)

    def pull(self, full, target):
        # TODO is 'target' ever NOT the current branch?
        previous = None
        for issue in self._dependencies(full, target):
            self.log.note("Merging with origin/%s..." % issue)
            self.git.command("checkout %s" % issue)
            if ("remotes/origin/%s" % issue) in self.branches:
                self.git.command("merge origin/%s" % issue)
            else:
                self.log.note("Nothing in origin to sync")
            if previous:
                self.git.command("merge %s" % previous)
            previous = issue

    def push(self, full):
        target = self.git.currentBranch
        self.pull(full, self.git.currentBranch)
        for issue in self._dependencies(full, self.git.currentBranch):
            self.git.command('checkout %s' % issue)
            self.git.command('push origin %s' % issue)

    def printHelp(self):
        self.log.note("Usage: git6820 <command> [options] <params>")

    def refresh(self, *args):
        """
            Sync with origin and master
        """
        self._checkNumArgs(0, args)
        self.setUp()
        self.pull(True, self.git.currentBranch)
        
    def review(self):
        """
            Create a pull request for the current issue, or update the existing
        """
        title = "#%s -> %s" % (self.issue, self.target)
        pulls = self.api.getPullRequests()
        current = [pull for pull in pulls if pull['title'] == title]
        if current:
            self.log.note("Pull request already exists.")
            link = current[0]['_links']['html']['href']
        else:
            newPullRequest = {
                'title': title,
                'base': self.target,
                'head': self.git.currentBranch,
                'body': title
            }
            pull = self.api.postPullRequest(newPullRequest)
            link = pull['issue_url']
        self.api.postLabel(self.issue, data=['pending-review'])
        self.log.success("Review posted successfully")
        self.log.success(link)

    def run(self, args):
        """
            Main method
        """
        if not args:
            self.printHelp()
        else:
            self.command = args[0]
            if self.command in self.COMMANDS.keys():
                self.COMMANDS[self.command](self, *args[1:])
            else:
                self.log.error("ERROR: Unknown command '%s'" % self.command)

    def setUp(self):
        """
            Fetch refs, get a list of branches, get current issue.

            This could be done in __init__, but I prefer deferring the computation.
        """
        self.git.command("fetch")
        self.setUpBranches()
        if "-" in self.git.currentBranch:
            self.target, self.issue = self.git.currentBranch.split("-", 1)
        else:
            self.target = self.git.currentBranch
            self.issue = None
        self.api = GithubApi(self.config)

    def setUpBranches(self):
        """
            Find current branch and all existing branches
        """
        branchLines = self.git.command("branch -a").split("\n") + ["remotes/origin/master"]
        self.branches = []
        for branch in branchLines:
            branch = branch.strip()
            if branch.startswith("* "):
                # Strip '* '
                branch = branch[2:]
                self.git.currentBranch = branch
            self.branches.append(branch)

    def status(self):
        self.log.note(self.git.command("status"))

    def _checkNumArgs(self, numExpected, args):
        if numExpected != len(args):
            self.log.warn("'%s %s' expected %s arguments, received %s" % (CMD_NAME, self.command, numExpected, list(args)))

    def _dependencies(self, pull, target):
        dependencies = []
        if pull:
            dependencies.append("master")
        if "-" in target:
            parent = target.split("-",1)[0]
            if parent != "master":
                dependencies.append(parent)
        dependencies.append(target)
        return dependencies

    def _getTarget(self, issue_data):
        """
            Find or infer the target milestone of the current issue
        """
        # Find the milestone set on github
        milestone = issue_data.get('milestone', None)
        # is the issue labeled as a hotfix on github?
        is_hotfix = 'hotfix' in [label['name'] for label in issue_data['labels']]
        if milestone is not None:
            return milestone['title']
        elif is_hotfix:
            return "master"
        else:
            self.log.error("Checkout failed. Set a milestone or label issue #%s as a hotfix." % issue_data['number'])

    def _preAdd(self, *args):
        self.setUp()
        if not args:
            self.log.error("Please specify files to add")
        else:
            self._requireIssue()
            self.add(args[-1], args[:-1])

    def _preCommit(self, *args):
        self.setUp()
        if not args:
            self.log.error("Please supply a commit message")
        else:
            self._requireIssue()
            self.commit(args[-1], args[:-1])

    def _preClose(self, *args):
        self._checkNumArgs(0, args)
        self.setUp()
        self._requireIssue()
        self.push(True)
        self.close()

    def _preCheckout(self, *args):
        self.setUp()
        no_pull = ("--no-pull" in args)
        issue_number = args[-1]
        try:
            # Make sure last argument is an integer
            issue_number_int = int(issue_number)
        except ValueError:
            self.log.error("Usage: %s checkout [--no-pull] <issue-number>" % CMD_NAME)
        self.checkout(issue_number, not no_pull)

    def _preReview(self, *args):
        self._checkNumArgs(0, args)
        self.setUp()
        self._requireIssue()
        self.push(True)
        self.review()

    def _requireIssue(self):
        if not self.issue:
            self.log.error("Must be on an issue branch to %s" % self.command)
    
    COMMANDS = {
        "add": _preAdd,
        "commit": _preCommit,
        "close": _preClose,
        "checkout": _preCheckout,
        "refresh": refresh,
        "review": _preReview,
        "st": status, # Everyone loves this alias, right?
        "status": status,
    }

if __name__ == "__main__":
    config = ConfigParser(INI_FILE).to_dict()
    Work(config).run(sys.argv[1:])
